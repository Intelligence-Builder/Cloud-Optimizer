service: Secrets Manager
description: AWS Secrets Manager - Secrets storage and rotation service
practices:
  - category: encryption
    title: Enable Automatic Secret Rotation
    description: |
      Enable automatic rotation for secrets to regularly update credentials without manual
      intervention. Secrets Manager integrates with RDS, Redshift, and DocumentDB for
      automatic rotation, and supports custom Lambda functions for other secret types.
    compliance_frameworks:
      - HIPAA
      - SOC2
      - PCI-DSS
      - GDPR
    implementation: |
      Configure rotation schedules based on compliance requirements (typically 30-90 days).
      Use AWS managed rotation functions for RDS databases. Create custom rotation functions
      for application credentials and API keys. Test rotation thoroughly before production.
    terraform_example: |
      # Secret with automatic rotation
      resource "aws_secretsmanager_secret" "db_password" {
        name                    = "prod/database/master-password"
        description             = "RDS master password with automatic rotation"
        recovery_window_in_days = 30

        rotation_rules {
          automatically_after_days = 30
        }
      }

      # Secret version with initial value
      resource "aws_secretsmanager_secret_version" "db_password" {
        secret_id = aws_secretsmanager_secret.db_password.id
        secret_string = jsonencode({
          username = "admin"
          password = random_password.db_password.result
          engine   = "postgres"
          host     = aws_db_instance.example.endpoint
          port     = 5432
          dbname   = "mydb"
        })
      }

      # Rotation configuration for RDS
      resource "aws_secretsmanager_secret_rotation" "db_password" {
        secret_id           = aws_secretsmanager_secret.db_password.id
        rotation_lambda_arn = aws_lambda_function.rotation.arn

        rotation_rules {
          automatically_after_days = 30
        }
      }

      # Lambda function for rotation (custom)
      resource "aws_lambda_function" "rotation" {
        filename      = "rotation_function.zip"
        function_name = "secretsmanager-rotation-function"
        role          = aws_iam_role.rotation_lambda.arn
        handler       = "index.handler"
        runtime       = "python3.11"

        environment {
          variables = {
            SECRETS_MANAGER_ENDPOINT = "https://secretsmanager.us-east-1.amazonaws.com"
          }
        }
      }

      # IAM role for rotation Lambda
      resource "aws_iam_role" "rotation_lambda" {
        name = "secretsmanager-rotation-role"

        assume_role_policy = jsonencode({
          Version = "2012-10-17"
          Statement = [{
            Action = "sts:AssumeRole"
            Effect = "Allow"
            Principal = {
              Service = "lambda.amazonaws.com"
            }
          }]
        })
      }
    cli_example: |
      # Enable rotation for RDS secret
      aws secretsmanager rotate-secret \
        --secret-id prod/database/master-password \
        --rotation-lambda-arn arn:aws:lambda:us-east-1:123456789012:function:SecretsManagerRDSPostgreSQLRotationSingleUser \
        --rotation-rules AutomaticallyAfterDays=30

      # Trigger immediate rotation
      aws secretsmanager rotate-secret \
        --secret-id prod/database/master-password

      # Check rotation status
      aws secretsmanager describe-secret \
        --secret-id prod/database/master-password \
        --query 'RotationEnabled'
    console_steps:
      - Navigate to Secrets Manager console at https://console.aws.amazon.com/secretsmanager/
      - Select secret
      - Click "Rotation configuration" section
      - Click "Edit rotation"
      - Check "Enable automatic rotation"
      - Select rotation schedule (e.g., 30 days)
      - For RDS/Redshift - select managed rotation function
      - For custom secrets - select custom Lambda function
      - Click "Save"
      - Test rotation by clicking "Rotate secret immediately"

  - category: access_control
    title: Implement Resource-Based Policies
    description: |
      Use resource-based policies on secrets to control access at the secret level. Combine
      with IAM policies for defense in depth. Restrict access to specific principals, VPC
      endpoints, or source IP addresses using condition keys.
    compliance_frameworks:
      - HIPAA
      - SOC2
      - PCI-DSS
      - GDPR
    implementation: |
      Attach resource policies to secrets that define who can access them. Use condition
      keys to restrict access based on VPC endpoint, source IP, or MFA. Deny access from
      outside your VPC for highly sensitive secrets.
    terraform_example: |
      resource "aws_secretsmanager_secret" "app_secret" {
        name                    = "prod/app/api-key"
        description             = "Application API key with restrictive policy"
        recovery_window_in_days = 30
      }

      resource "aws_secretsmanager_secret_version" "app_secret" {
        secret_id     = aws_secretsmanager_secret.app_secret.id
        secret_string = random_password.api_key.result
      }

      # Resource policy for secret
      resource "aws_secretsmanager_secret_policy" "app_secret" {
        secret_arn = aws_secretsmanager_secret.app_secret.arn

        policy = jsonencode({
          Version = "2012-10-17"
          Statement = [
            {
              Sid    = "AllowAppRoleAccess"
              Effect = "Allow"
              Principal = {
                AWS = aws_iam_role.app_role.arn
              }
              Action   = "secretsmanager:GetSecretValue"
              Resource = "*"
            },
            {
              Sid    = "RestrictToVPCEndpoint"
              Effect = "Deny"
              Principal = "*"
              Action   = "secretsmanager:GetSecretValue"
              Resource = "*"
              Condition = {
                StringNotEquals = {
                  "aws:SourceVpce" = aws_vpc_endpoint.secretsmanager.id
                }
              }
            },
            {
              Sid    = "RequireMFAForAdmins"
              Effect = "Deny"
              Principal = {
                AWS = "arn:aws:iam::123456789012:role/AdminRole"
              }
              Action = [
                "secretsmanager:DeleteSecret",
                "secretsmanager:PutSecretValue"
              ]
              Resource = "*"
              Condition = {
                BoolIfExists = {
                  "aws:MultiFactorAuthPresent" = "false"
                }
              }
            }
          ]
        })
      }
    cli_example: |
      # Attach resource policy
      aws secretsmanager put-resource-policy \
        --secret-id prod/app/api-key \
        --resource-policy file://secret-policy.json

      # Get resource policy
      aws secretsmanager get-resource-policy \
        --secret-id prod/app/api-key

      # Delete resource policy
      aws secretsmanager delete-resource-policy \
        --secret-id prod/app/api-key
    console_steps:
      - Navigate to Secrets Manager console
      - Select secret
      - Go to "Resource permissions" section
      - Click "Edit permissions"
      - Enter resource policy JSON
      - Validate policy syntax
      - Click "Save"
      - Test access with different principals

  - category: logging
    title: Monitor Secret Access
    description: |
      Enable CloudTrail logging for Secrets Manager API calls and create CloudWatch alarms
      for suspicious activity. Monitor failed access attempts, secret deletions, and
      unusual access patterns.
    compliance_frameworks:
      - HIPAA
      - SOC2
      - PCI-DSS
      - GDPR
    implementation: |
      Ensure CloudTrail is logging Secrets Manager events. Create metric filters for
      failed GetSecretValue attempts, DeleteSecret calls, and access from unexpected
      principals. Use CloudWatch Insights for detailed analysis.
    terraform_example: |
      # Metric filter for failed secret access
      resource "aws_cloudwatch_log_metric_filter" "secret_access_denied" {
        name           = "secrets-access-denied"
        log_group_name = aws_cloudwatch_log_group.cloudtrail.name
        pattern        = '{ $.eventSource = "secretsmanager.amazonaws.com" && $.errorCode = "AccessDenied*" }'

        metric_transformation {
          name      = "SecretsAccessDenied"
          namespace = "Security/SecretsManager"
          value     = "1"
        }
      }

      resource "aws_cloudwatch_metric_alarm" "secret_access_denied" {
        alarm_name          = "secrets-access-denied-alert"
        comparison_operator = "GreaterThanThreshold"
        evaluation_periods  = "1"
        metric_name         = "SecretsAccessDenied"
        namespace           = "Security/SecretsManager"
        period              = "300"
        statistic           = "Sum"
        threshold           = "5"
        alarm_description   = "Alert on multiple failed secret access attempts"
        alarm_actions       = [aws_sns_topic.security_alerts.arn]
      }

      # Metric filter for secret deletion
      resource "aws_cloudwatch_log_metric_filter" "secret_deletion" {
        name           = "secret-deletion"
        log_group_name = aws_cloudwatch_log_group.cloudtrail.name
        pattern        = '{ $.eventSource = "secretsmanager.amazonaws.com" && $.eventName = "DeleteSecret" }'

        metric_transformation {
          name      = "SecretDeletion"
          namespace = "Security/SecretsManager"
          value     = "1"
        }
      }

      resource "aws_cloudwatch_metric_alarm" "secret_deletion" {
        alarm_name          = "secret-deletion-alert"
        comparison_operator = "GreaterThanOrEqualToThreshold"
        evaluation_periods  = "1"
        metric_name         = "SecretDeletion"
        namespace           = "Security/SecretsManager"
        period              = "60"
        statistic           = "Sum"
        threshold           = "1"
        alarm_description   = "Alert on any secret deletion"
        alarm_actions       = [aws_sns_topic.security_alerts.arn]
      }
    cli_example: |
      # Query CloudTrail for Secrets Manager events
      aws cloudtrail lookup-events \
        --lookup-attributes AttributeKey=EventName,AttributeValue=GetSecretValue \
        --max-results 50

      # CloudWatch Insights query
      aws logs start-query \
        --log-group-name /aws/cloudtrail/organization \
        --start-time $(date -u -d '24 hours ago' +%s) \
        --end-time $(date -u +%s) \
        --query-string 'fields @timestamp, eventName, userIdentity.arn, requestParameters.secretId, errorCode
          | filter eventSource = "secretsmanager.amazonaws.com"
          | sort @timestamp desc'
    console_steps:
      - Ensure CloudTrail is enabled and logging to CloudWatch
      - Navigate to CloudWatch console
      - Go to "Logs" > "Log groups"
      - Select CloudTrail log group
      - Create metric filters for:
        - Failed GetSecretValue attempts
        - DeleteSecret operations
        - PutSecretValue from unexpected principals
      - Create alarms for each metric
      - Use CloudWatch Insights for detailed analysis

  - category: encryption
    title: Encrypt Secrets with Customer-Managed KMS Keys
    description: |
      Use customer-managed KMS keys to encrypt secrets instead of AWS managed keys. This
      provides additional control over key policies, rotation, and access patterns. Enables
      key usage auditing and fine-grained access control.
    compliance_frameworks:
      - HIPAA
      - SOC2
      - PCI-DSS
      - GDPR
    implementation: |
      Create dedicated KMS keys for Secrets Manager with appropriate key policies. Enable
      automatic key rotation. Use separate keys for different environments or sensitivity
      levels. Grant decrypt permissions only to authorized principals.
    terraform_example: |
      # KMS key for Secrets Manager
      resource "aws_kms_key" "secrets" {
        description             = "KMS key for Secrets Manager encryption"
        deletion_window_in_days = 30
        enable_key_rotation     = true

        policy = jsonencode({
          Version = "2012-10-17"
          Statement = [
            {
              Sid    = "Enable IAM User Permissions"
              Effect = "Allow"
              Principal = {
                AWS = "arn:aws:iam::123456789012:root"
              }
              Action   = "kms:*"
              Resource = "*"
            },
            {
              Sid    = "Allow Secrets Manager"
              Effect = "Allow"
              Principal = {
                Service = "secretsmanager.amazonaws.com"
              }
              Action = [
                "kms:Decrypt",
                "kms:GenerateDataKey",
                "kms:CreateGrant"
              ]
              Resource = "*"
              Condition = {
                StringEquals = {
                  "kms:ViaService" = "secretsmanager.us-east-1.amazonaws.com"
                }
              }
            },
            {
              Sid    = "Allow Application to Decrypt"
              Effect = "Allow"
              Principal = {
                AWS = aws_iam_role.app_role.arn
              }
              Action = "kms:Decrypt"
              Resource = "*"
              Condition = {
                StringEquals = {
                  "kms:ViaService" = "secretsmanager.us-east-1.amazonaws.com"
                }
              }
            }
          ]
        })
      }

      resource "aws_kms_alias" "secrets" {
        name          = "alias/secretsmanager-encryption"
        target_key_id = aws_kms_key.secrets.key_id
      }

      # Secret with customer-managed key
      resource "aws_secretsmanager_secret" "encrypted" {
        name                    = "prod/app/database-credentials"
        description             = "Database credentials encrypted with CMK"
        kms_key_id              = aws_kms_key.secrets.arn
        recovery_window_in_days = 30
      }
    cli_example: |
      # Create secret with custom KMS key
      aws secretsmanager create-secret \
        --name prod/app/database-credentials \
        --description "Database credentials encrypted with CMK" \
        --kms-key-id arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012 \
        --secret-string '{"username":"admin","password":"SecurePassword123!"}'

      # Update secret to use different KMS key
      aws secretsmanager update-secret \
        --secret-id prod/app/database-credentials \
        --kms-key-id arn:aws:kms:us-east-1:123456789012:key/new-key-id
    console_steps:
      - First, create customer-managed KMS key in KMS console
      - Configure key policy for Secrets Manager
      - Navigate to Secrets Manager console
      - When creating secret, expand "Encryption key"
      - Select "Choose an AWS KMS key"
      - Select your customer-managed key
      - Complete secret creation
      - For existing secrets - edit encryption settings

  - category: access_control
    title: Use VPC Endpoints for Private Access
    description: |
      Create VPC endpoints for Secrets Manager to access secrets privately without
      traversing the internet. This improves security and reduces exposure of secret
      requests. Combine with resource policies to restrict access to VPC endpoint only.
    compliance_frameworks:
      - HIPAA
      - SOC2
      - PCI-DSS
    implementation: |
      Create interface VPC endpoints for Secrets Manager in private subnets. Update
      security groups to allow HTTPS traffic from application instances. Modify secret
      resource policies to require access through VPC endpoint. Enable private DNS.
    terraform_example: |
      # VPC endpoint for Secrets Manager
      resource "aws_vpc_endpoint" "secretsmanager" {
        vpc_id              = aws_vpc.main.id
        service_name        = "com.amazonaws.us-east-1.secretsmanager"
        vpc_endpoint_type   = "Interface"
        subnet_ids          = [aws_subnet.private_a.id, aws_subnet.private_b.id]
        security_group_ids  = [aws_security_group.vpc_endpoints.id]
        private_dns_enabled = true

        tags = {
          Name = "secretsmanager-endpoint"
        }
      }

      # Security group for VPC endpoint
      resource "aws_security_group" "vpc_endpoints" {
        name        = "vpc-endpoints-sg"
        description = "Security group for VPC endpoints"
        vpc_id      = aws_vpc.main.id

        ingress {
          from_port   = 443
          to_port     = 443
          protocol    = "tcp"
          cidr_blocks = [aws_vpc.main.cidr_block]
          description = "HTTPS from VPC"
        }

        tags = {
          Name = "vpc-endpoints-sg"
        }
      }

      # Secret policy requiring VPC endpoint
      resource "aws_secretsmanager_secret_policy" "vpc_only" {
        secret_arn = aws_secretsmanager_secret.app_secret.arn

        policy = jsonencode({
          Version = "2012-10-17"
          Statement = [{
            Sid    = "RequireVPCEndpoint"
            Effect = "Deny"
            Principal = "*"
            Action = "secretsmanager:GetSecretValue"
            Resource = "*"
            Condition = {
              StringNotEquals = {
                "aws:SourceVpce" = aws_vpc_endpoint.secretsmanager.id
              }
            }
          }]
        })
      }
    cli_example: |
      # Create VPC endpoint
      aws ec2 create-vpc-endpoint \
        --vpc-id vpc-12345678 \
        --vpc-endpoint-type Interface \
        --service-name com.amazonaws.us-east-1.secretsmanager \
        --subnet-ids subnet-12345678 subnet-87654321 \
        --security-group-ids sg-12345678 \
        --private-dns-enabled

      # Test access through VPC endpoint
      aws secretsmanager get-secret-value \
        --secret-id prod/app/database-credentials \
        --endpoint-url https://vpce-12345678-abcdefgh.secretsmanager.us-east-1.vpce.amazonaws.com
    console_steps:
      - Navigate to VPC console
      - Go to "Endpoints"
      - Click "Create endpoint"
      - Select "AWS services"
      - Search for "secretsmanager"
      - Select service
      - Choose VPC
      - Select private subnets
      - Select security group allowing HTTPS from VPC
      - Enable private DNS
      - Click "Create endpoint"
      - Update application to use endpoint if not using private DNS
