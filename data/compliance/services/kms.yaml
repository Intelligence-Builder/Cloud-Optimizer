service: KMS
description: AWS Key Management Service - Managed encryption key service
best_practices:
  - category: encryption
    title: Enable Automatic Key Rotation
    description: |
      Enable automatic key rotation for customer-managed KMS keys. AWS KMS automatically
      rotates keys every year while keeping old key material available for decryption.
      This reduces the risk of key compromise and meets compliance requirements.
    compliance_frameworks:
      - HIPAA
      - SOC2
      - PCI-DSS
      - GDPR
    implementation: |
      Enable automatic rotation when creating customer-managed keys. AWS maintains all
      previous versions of the key material for decryption. Rotation does not affect
      AWS managed keys (they rotate every 3 years automatically).
    terraform_example: |
      resource "aws_kms_key" "example" {
        description             = "Customer managed key with rotation"
        deletion_window_in_days = 30
        enable_key_rotation     = true

        tags = {
          Name = "app-encryption-key"
        }
      }

      resource "aws_kms_alias" "example" {
        name          = "alias/app-encryption"
        target_key_id = aws_kms_key.example.key_id
      }

      # Monitor rotation with CloudWatch
      resource "aws_cloudwatch_metric_alarm" "key_rotation" {
        alarm_name          = "kms-key-rotation-check"
        comparison_operator = "LessThanThreshold"
        evaluation_periods  = "1"
        metric_name         = "KeyRotation"
        namespace           = "AWS/KMS"
        period              = "86400"
        statistic           = "Sum"
        threshold           = "1"
        alarm_description   = "Alert if key rotation is not enabled"

        dimensions = {
          KeyId = aws_kms_key.example.id
        }
      }
    cli_example: |
      # Create key with rotation enabled
      aws kms create-key \
        --description "Customer managed key with rotation" \
        --key-usage ENCRYPT_DECRYPT \
        --origin AWS_KMS

      # Enable rotation on existing key
      aws kms enable-key-rotation --key-id 12345678-1234-1234-1234-123456789012

      # Check rotation status
      aws kms get-key-rotation-status --key-id 12345678-1234-1234-1234-123456789012

      # List all keys and check rotation
      aws kms list-keys | jq -r '.Keys[].KeyId' | while read key; do
        echo "Key: $key"
        aws kms get-key-rotation-status --key-id $key
      done
    console_steps:
      - Navigate to KMS console at https://console.aws.amazon.com/kms/
      - Select "Customer managed keys"
      - Click on the key
      - Go to "Key rotation" tab
      - Click "Edit"
      - Check "Automatically rotate this KMS key every year"
      - Click "Save"
      - For new keys - enable during creation wizard

  - category: access_control
    title: Implement Least Privilege Key Policies
    description: |
      Use key policies to control access to KMS keys. Implement least privilege by granting
      only necessary permissions to specific principals. Use key policies as the primary
      access control mechanism and IAM policies for additional controls.
    compliance_frameworks:
      - HIPAA
      - SOC2
      - PCI-DSS
      - GDPR
    implementation: |
      Create specific key policies for each use case. Separate key administration from
      key usage. Use condition keys to restrict access by source IP, VPC, or other context.
      Avoid using "*" for principals unless absolutely necessary.
    terraform_example: |
      resource "aws_kms_key" "example" {
        description             = "Application encryption key"
        deletion_window_in_days = 30
        enable_key_rotation     = true

        policy = jsonencode({
          Version = "2012-10-17"
          Statement = [
            {
              Sid    = "Enable IAM User Permissions"
              Effect = "Allow"
              Principal = {
                AWS = "arn:aws:iam::123456789012:root"
              }
              Action   = "kms:*"
              Resource = "*"
            },
            {
              Sid    = "Allow Key Administrators"
              Effect = "Allow"
              Principal = {
                AWS = [
                  "arn:aws:iam::123456789012:role/KeyAdministrator"
                ]
              }
              Action = [
                "kms:Create*",
                "kms:Describe*",
                "kms:Enable*",
                "kms:List*",
                "kms:Put*",
                "kms:Update*",
                "kms:Revoke*",
                "kms:Disable*",
                "kms:Get*",
                "kms:Delete*",
                "kms:TagResource",
                "kms:UntagResource",
                "kms:ScheduleKeyDeletion",
                "kms:CancelKeyDeletion"
              ]
              Resource = "*"
            },
            {
              Sid    = "Allow Application Use"
              Effect = "Allow"
              Principal = {
                AWS = "arn:aws:iam::123456789012:role/AppRole"
              }
              Action = [
                "kms:Decrypt",
                "kms:DescribeKey"
              ]
              Resource = "*"
              Condition = {
                StringEquals = {
                  "kms:ViaService" = [
                    "s3.us-east-1.amazonaws.com"
                  ]
                }
              }
            },
            {
              Sid    = "Allow Encryption by Application"
              Effect = "Allow"
              Principal = {
                AWS = "arn:aws:iam::123456789012:role/AppRole"
              }
              Action = [
                "kms:Encrypt",
                "kms:GenerateDataKey",
                "kms:GenerateDataKeyWithoutPlaintext"
              ]
              Resource = "*"
            }
          ]
        })
      }
    cli_example: |
      # Get current key policy
      aws kms get-key-policy \
        --key-id 12345678-1234-1234-1234-123456789012 \
        --policy-name default

      # Update key policy
      aws kms put-key-policy \
        --key-id 12345678-1234-1234-1234-123456789012 \
        --policy-name default \
        --policy file://key-policy.json

      # Create grant for temporary access
      aws kms create-grant \
        --key-id 12345678-1234-1234-1234-123456789012 \
        --grantee-principal arn:aws:iam::123456789012:role/AppRole \
        --operations Decrypt GenerateDataKey
    console_steps:
      - Navigate to KMS console
      - Select "Customer managed keys"
      - Click on key
      - Go to "Key policy" tab
      - Review default key policy
      - Click "Switch to policy view" for advanced editing
      - Define key administrators (who can manage the key)
      - Define key users (who can use the key for cryptographic operations)
      - Add conditions for additional restrictions
      - Click "Save changes"

  - category: logging
    title: Monitor KMS Key Usage
    description: |
      Enable CloudTrail logging for all KMS API calls and create CloudWatch alarms for
      suspicious activity. Monitor key usage patterns, failed decryption attempts, and
      key policy changes.
    compliance_frameworks:
      - HIPAA
      - SOC2
      - PCI-DSS
      - GDPR
    implementation: |
      Ensure CloudTrail is logging KMS events to CloudWatch Logs. Create metric filters
      and alarms for key deletion attempts, policy changes, and unusual usage patterns.
      Use CloudWatch Insights to analyze KMS logs.
    terraform_example: |
      # CloudWatch Log Group for CloudTrail
      resource "aws_cloudwatch_log_group" "cloudtrail" {
        name              = "/aws/cloudtrail/kms"
        retention_in_days = 90
      }

      # Metric filter for key deletion attempts
      resource "aws_cloudwatch_log_metric_filter" "key_deletion" {
        name           = "kms-key-deletion-attempts"
        log_group_name = aws_cloudwatch_log_group.cloudtrail.name
        pattern        = "{ $.eventName = \"ScheduleKeyDeletion\" || $.eventName = \"DisableKey\" }"

        metric_transformation {
          name      = "KMSKeyDeletionAttempts"
          namespace = "Security/KMS"
          value     = "1"
        }
      }

      # Alarm for key deletion
      resource "aws_cloudwatch_metric_alarm" "key_deletion" {
        alarm_name          = "kms-key-deletion-alert"
        comparison_operator = "GreaterThanThreshold"
        evaluation_periods  = "1"
        metric_name         = "KMSKeyDeletionAttempts"
        namespace           = "Security/KMS"
        period              = "300"
        statistic           = "Sum"
        threshold           = "0"
        alarm_description   = "Alert on KMS key deletion attempts"
        alarm_actions       = [aws_sns_topic.security_alerts.arn]
      }

      # Metric filter for failed decryption
      resource "aws_cloudwatch_log_metric_filter" "failed_decrypt" {
        name           = "kms-failed-decrypt"
        log_group_name = aws_cloudwatch_log_group.cloudtrail.name
        pattern        = "{ $.eventName = \"Decrypt\" && $.errorCode = \"*\" }"

        metric_transformation {
          name      = "KMSFailedDecryption"
          namespace = "Security/KMS"
          value     = "1"
        }
      }

      resource "aws_cloudwatch_metric_alarm" "failed_decrypt" {
        alarm_name          = "kms-failed-decrypt-alert"
        comparison_operator = "GreaterThanThreshold"
        evaluation_periods  = "1"
        metric_name         = "KMSFailedDecryption"
        namespace           = "Security/KMS"
        period              = "300"
        statistic           = "Sum"
        threshold           = "10"
        alarm_description   = "Alert on excessive KMS failed decryption attempts"
        alarm_actions       = [aws_sns_topic.security_alerts.arn]
      }
    cli_example: |
      # Search CloudTrail for KMS events
      aws cloudtrail lookup-events \
        --lookup-attributes AttributeKey=ResourceType,AttributeValue=AWS::KMS::Key \
        --max-results 50

      # Query CloudWatch Logs Insights
      aws logs start-query \
        --log-group-name /aws/cloudtrail/kms \
        --start-time $(date -u -d '1 hour ago' +%s) \
        --end-time $(date -u +%s) \
        --query-string 'fields @timestamp, eventName, errorCode, sourceIPAddress
          | filter eventSource = "kms.amazonaws.com"
          | stats count() by eventName'
    console_steps:
      - Ensure CloudTrail is enabled and logging to CloudWatch
      - Navigate to CloudWatch console
      - Go to "Logs" > "Log groups"
      - Find CloudTrail log group
      - Click "Create metric filter"
      - Define filter pattern for KMS events
      - Create alarm based on metric
      - For key-specific monitoring, use KMS console metrics

  - category: access_control
    title: Use Separate Keys Per Service or Application
    description: |
      Create separate KMS keys for different services, applications, or data classifications.
      This provides better access control, easier key rotation, and limits blast radius
      in case of key compromise.
    compliance_frameworks:
      - HIPAA
      - SOC2
      - PCI-DSS
      - GDPR
    implementation: |
      Design a key hierarchy based on data sensitivity and service boundaries. Use separate
      keys for production and non-production environments. Create service-specific keys
      and use aliases for easier key management.
    terraform_example: |
      # Key for S3 encryption
      resource "aws_kms_key" "s3" {
        description             = "KMS key for S3 bucket encryption"
        deletion_window_in_days = 30
        enable_key_rotation     = true

        tags = {
          Service     = "S3"
          Environment = "production"
        }
      }

      resource "aws_kms_alias" "s3" {
        name          = "alias/s3-encryption"
        target_key_id = aws_kms_key.s3.key_id
      }

      # Key for RDS encryption
      resource "aws_kms_key" "rds" {
        description             = "KMS key for RDS encryption"
        deletion_window_in_days = 30
        enable_key_rotation     = true

        tags = {
          Service     = "RDS"
          Environment = "production"
        }
      }

      resource "aws_kms_alias" "rds" {
        name          = "alias/rds-encryption"
        target_key_id = aws_kms_key.rds.key_id
      }

      # Key for Secrets Manager
      resource "aws_kms_key" "secrets" {
        description             = "KMS key for Secrets Manager"
        deletion_window_in_days = 30
        enable_key_rotation     = true

        tags = {
          Service     = "SecretsManager"
          Environment = "production"
        }
      }

      resource "aws_kms_alias" "secrets" {
        name          = "alias/secrets-encryption"
        target_key_id = aws_kms_key.secrets.key_id
      }

      # Use service-specific keys
      resource "aws_s3_bucket_server_side_encryption_configuration" "example" {
        bucket = aws_s3_bucket.example.id

        rule {
          apply_server_side_encryption_by_default {
            sse_algorithm     = "aws:kms"
            kms_master_key_id = aws_kms_key.s3.arn
          }
        }
      }
    cli_example: |
      # Create service-specific key
      aws kms create-key \
        --description "S3 encryption key" \
        --tags TagKey=Service,TagValue=S3 TagKey=Environment,TagValue=production

      # Create alias
      aws kms create-alias \
        --alias-name alias/s3-encryption \
        --target-key-id 12345678-1234-1234-1234-123456789012

      # List keys with tags
      aws kms list-keys | jq -r '.Keys[].KeyId' | while read key; do
        echo "Key: $key"
        aws kms list-resource-tags --key-id $key
      done
    console_steps:
      - Navigate to KMS console
      - Plan key architecture by service/environment
      - Click "Create key" for each service
      - Choose "Symmetric" and "Encrypt and decrypt"
      - Add descriptive name and tags
      - Define key administrators
      - Define key users (service roles)
      - Create alias for easier reference
      - Document key usage in tags and description

  - category: access_control
    title: Implement Key Policy Conditions
    description: |
      Use condition keys in KMS key policies to add context-based restrictions. Limit
      key usage based on VPC endpoint, source IP, encryption context, or AWS service.
      This provides defense in depth beyond principal-based access control.
    compliance_frameworks:
      - HIPAA
      - SOC2
      - PCI-DSS
    implementation: |
      Add condition keys to key policy statements. Use kms:ViaService to restrict usage
      to specific AWS services. Use kms:EncryptionContext for application-level validation.
      Use aws:SourceVpce or aws:SourceIp for network-based restrictions.
    terraform_example: |
      resource "aws_kms_key" "restricted" {
        description             = "KMS key with policy conditions"
        deletion_window_in_days = 30
        enable_key_rotation     = true

        policy = jsonencode({
          Version = "2012-10-17"
          Statement = [
            {
              Sid    = "Enable IAM User Permissions"
              Effect = "Allow"
              Principal = {
                AWS = "arn:aws:iam::123456789012:root"
              }
              Action   = "kms:*"
              Resource = "*"
            },
            {
              Sid    = "Restrict to VPC Endpoint"
              Effect = "Allow"
              Principal = {
                AWS = "arn:aws:iam::123456789012:role/AppRole"
              }
              Action = [
                "kms:Decrypt",
                "kms:GenerateDataKey"
              ]
              Resource = "*"
              Condition = {
                StringEquals = {
                  "aws:SourceVpce" = "vpce-12345678"
                }
              }
            },
            {
              Sid    = "Require Encryption Context"
              Effect = "Allow"
              Principal = {
                AWS = "arn:aws:iam::123456789012:role/AppRole"
              }
              Action = [
                "kms:Encrypt",
                "kms:Decrypt"
              ]
              Resource = "*"
              Condition = {
                StringEquals = {
                  "kms:EncryptionContext:AppName" = "MyApp"
                }
              }
            },
            {
              Sid    = "Restrict to Specific Service"
              Effect = "Allow"
              Principal = {
                AWS = "arn:aws:iam::123456789012:role/LambdaRole"
              }
              Action = [
                "kms:Decrypt"
              ]
              Resource = "*"
              Condition = {
                StringEquals = {
                  "kms:ViaService" = "lambda.us-east-1.amazonaws.com"
                }
              }
            }
          ]
        })
      }
    cli_example: |
      # Encrypt with encryption context
      aws kms encrypt \
        --key-id alias/app-key \
        --plaintext fileb://secret.txt \
        --encryption-context AppName=MyApp,Environment=prod \
        --output text \
        --query CiphertextBlob | base64 -d > encrypted.bin

      # Decrypt with encryption context (must match)
      aws kms decrypt \
        --ciphertext-blob fileb://encrypted.bin \
        --encryption-context AppName=MyApp,Environment=prod \
        --output text \
        --query Plaintext | base64 -d
    console_steps:
      - Navigate to KMS console
      - Select key
      - Go to "Key policy" tab
      - Switch to policy view
      - Add Condition block to relevant statements
      - Use condition keys like:
        - kms:ViaService for service restriction
        - aws:SourceVpce for VPC endpoint
        - kms:EncryptionContext for application context
        - aws:SourceIp for IP-based access
      - Test conditions thoroughly before production use
      - Document condition requirements for developers
