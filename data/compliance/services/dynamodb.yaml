service: DynamoDB
description: Amazon DynamoDB - NoSQL database service
practices:
  - category: encryption
    title: Enable Encryption at Rest
    description: |
      Enable encryption at rest for all DynamoDB tables using AWS KMS. DynamoDB encrypts
      all data including base tables, indexes, streams, and backups. Use customer-managed
      KMS keys for additional control over encryption keys and access.
    compliance_frameworks:
      - HIPAA
      - SOC2
      - PCI-DSS
      - GDPR
    implementation: |
      Enable encryption when creating the table. DynamoDB supports AWS owned keys (default),
      AWS managed keys (aws/dynamodb), and customer-managed keys. Choose customer-managed
      keys for compliance requirements and key rotation control.
    terraform_example: |
      # KMS key for DynamoDB
      resource "aws_kms_key" "dynamodb" {
        description             = "KMS key for DynamoDB encryption"
        deletion_window_in_days = 30
        enable_key_rotation     = true

        tags = {
          Service = "DynamoDB"
        }
      }

      resource "aws_kms_alias" "dynamodb" {
        name          = "alias/dynamodb-encryption"
        target_key_id = aws_kms_key.dynamodb.key_id
      }

      # DynamoDB table with encryption
      resource "aws_dynamodb_table" "example" {
        name           = "users"
        billing_mode   = "PAY_PER_REQUEST"
        hash_key       = "userId"
        range_key      = "timestamp"

        attribute {
          name = "userId"
          type = "S"
        }

        attribute {
          name = "timestamp"
          type = "N"
        }

        # Enable encryption with customer-managed key
        server_side_encryption {
          enabled     = true
          kms_key_arn = aws_kms_key.dynamodb.arn
        }

        # Enable point-in-time recovery
        point_in_time_recovery {
          enabled = true
        }

        tags = {
          Name        = "users-table"
          Environment = "production"
        }
      }
    cli_example: |
      # Create table with encryption
      aws dynamodb create-table \
        --table-name users \
        --attribute-definitions \
          AttributeName=userId,AttributeType=S \
          AttributeName=timestamp,AttributeType=N \
        --key-schema \
          AttributeName=userId,KeyType=HASH \
          AttributeName=timestamp,KeyType=RANGE \
        --billing-mode PAY_PER_REQUEST \
        --sse-specification \
          Enabled=true,SSEType=KMS,KMSMasterKeyId=arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012

      # Update existing table to use KMS
      aws dynamodb update-table \
        --table-name users \
        --sse-specification \
          Enabled=true,SSEType=KMS,KMSMasterKeyId=arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012
    console_steps:
      - Navigate to DynamoDB console at https://console.aws.amazon.com/dynamodb/
      - Click "Create table"
      - Enter table name and primary key
      - Expand "Table settings"
      - Under "Encryption at rest"
      - Select "AWS owned key" (default), "AWS managed key", or "Customer managed key"
      - If customer managed - select KMS key
      - Configure other settings
      - Click "Create table"

  - category: backup
    title: Enable Point-in-Time Recovery
    description: |
      Enable point-in-time recovery (PITR) to protect against accidental writes or deletes.
      PITR provides continuous backups for the last 35 days, allowing table restoration
      to any point in time within the recovery window.
    compliance_frameworks:
      - HIPAA
      - SOC2
      - PCI-DSS
      - GDPR
    implementation: |
      Enable PITR on all production tables. PITR has minimal impact on performance and
      provides comprehensive backup coverage. Create restore procedures and test recovery
      regularly. Consider enabling PITR on tables containing critical business data.
    terraform_example: |
      resource "aws_dynamodb_table" "example" {
        name         = "orders"
        billing_mode = "PAY_PER_REQUEST"
        hash_key     = "orderId"

        attribute {
          name = "orderId"
          type = "S"
        }

        # Enable point-in-time recovery
        point_in_time_recovery {
          enabled = true
        }

        server_side_encryption {
          enabled = true
        }

        tags = {
          Name = "orders-table"
        }
      }

      # On-demand backup (in addition to PITR)
      resource "aws_dynamodb_table_item" "backup_schedule" {
        table_name = aws_dynamodb_table.example.name
        hash_key   = aws_dynamodb_table.example.hash_key

        # Use EventBridge and Lambda to create scheduled backups
      }
    cli_example: |
      # Enable PITR
      aws dynamodb update-continuous-backups \
        --table-name orders \
        --point-in-time-recovery-specification PointInTimeRecoveryEnabled=true

      # Check PITR status
      aws dynamodb describe-continuous-backups --table-name orders

      # Restore table to specific point in time
      aws dynamodb restore-table-to-point-in-time \
        --source-table-name orders \
        --target-table-name orders-restored \
        --restore-date-time 2024-01-01T10:00:00

      # Create on-demand backup
      aws dynamodb create-backup \
        --table-name orders \
        --backup-name orders-backup-$(date +%Y%m%d)
    console_steps:
      - Navigate to DynamoDB console
      - Select table
      - Go to "Backups" tab
      - Click "Enable" under "Point-in-time recovery"
      - Confirm enabling PITR
      - To restore:
        - Click "Restore to point-in-time"
        - Choose restore time
        - Enter new table name
        - Click "Restore table"

  - category: network_security
    title: Use VPC Endpoints for Private Access
    description: |
      Create VPC endpoints for DynamoDB to access tables from VPC without traversing
      the internet. This improves security, reduces latency, and eliminates data transfer
      charges for traffic between VPC and DynamoDB.
    compliance_frameworks:
      - HIPAA
      - SOC2
      - PCI-DSS
    implementation: |
      Create Gateway VPC endpoints for DynamoDB in each VPC that needs access. Update
      route tables to route DynamoDB traffic through the endpoint. Use endpoint policies
      to restrict access to specific tables or actions.
    terraform_example: |
      # VPC endpoint for DynamoDB
      resource "aws_vpc_endpoint" "dynamodb" {
        vpc_id       = aws_vpc.main.id
        service_name = "com.amazonaws.us-east-1.dynamodb"

        route_table_ids = [
          aws_route_table.private_a.id,
          aws_route_table.private_b.id
        ]

        policy = jsonencode({
          Version = "2012-10-17"
          Statement = [
            {
              Effect = "Allow"
              Principal = "*"
              Action = [
                "dynamodb:GetItem",
                "dynamodb:PutItem",
                "dynamodb:Query",
                "dynamodb:Scan",
                "dynamodb:UpdateItem",
                "dynamodb:DeleteItem"
              ]
              Resource = [
                "arn:aws:dynamodb:us-east-1:123456789012:table/users",
                "arn:aws:dynamodb:us-east-1:123456789012:table/orders"
              ]
            },
            {
              Effect = "Deny"
              Principal = "*"
              Action = "dynamodb:*"
              Resource = "*"
              Condition = {
                StringNotEquals = {
                  "aws:PrincipalAccount" = "123456789012"
                }
              }
            }
          ]
        })

        tags = {
          Name = "dynamodb-endpoint"
        }
      }
    cli_example: |
      # Create VPC endpoint
      aws ec2 create-vpc-endpoint \
        --vpc-id vpc-12345678 \
        --service-name com.amazonaws.us-east-1.dynamodb \
        --route-table-ids rtb-12345678 rtb-87654321

      # Update endpoint policy
      aws ec2 modify-vpc-endpoint \
        --vpc-endpoint-id vpce-12345678 \
        --policy-document file://dynamodb-endpoint-policy.json

      # Describe endpoint
      aws ec2 describe-vpc-endpoints --vpc-endpoint-ids vpce-12345678
    console_steps:
      - Navigate to VPC console
      - Go to "Endpoints"
      - Click "Create endpoint"
      - Select "AWS services"
      - Search for "dynamodb"
      - Select DynamoDB service
      - Choose VPC
      - Select route tables for private subnets
      - Optionally add endpoint policy
      - Click "Create endpoint"

  - category: logging
    title: Enable CloudWatch Alarms for Table Metrics
    description: |
      Create CloudWatch alarms for DynamoDB table metrics to monitor read/write capacity,
      throttled requests, system errors, and latency. Set up alerts for capacity issues,
      error spikes, and performance degradation.
    compliance_frameworks:
      - SOC2
    implementation: |
      Monitor key metrics like ConsumedReadCapacityUnits, ConsumedWriteCapacityUnits,
      UserErrors, SystemErrors, and SuccessfulRequestLatency. Create alarms based on
      workload patterns and SLA requirements. Use Auto Scaling for provisioned capacity.
    terraform_example: |
      # Alarm for throttled read requests
      resource "aws_cloudwatch_metric_alarm" "read_throttles" {
        alarm_name          = "dynamodb-read-throttles"
        comparison_operator = "GreaterThanThreshold"
        evaluation_periods  = "2"
        metric_name         = "ReadThrottleEvents"
        namespace           = "AWS/DynamoDB"
        period              = "60"
        statistic           = "Sum"
        threshold           = "10"
        alarm_description   = "Alert when read requests are throttled"
        alarm_actions       = [aws_sns_topic.ops_alerts.arn]

        dimensions = {
          TableName = aws_dynamodb_table.example.name
        }
      }

      # Alarm for throttled write requests
      resource "aws_cloudwatch_metric_alarm" "write_throttles" {
        alarm_name          = "dynamodb-write-throttles"
        comparison_operator = "GreaterThanThreshold"
        evaluation_periods  = "2"
        metric_name         = "WriteThrottleEvents"
        namespace           = "AWS/DynamoDB"
        period              = "60"
        statistic           = "Sum"
        threshold           = "10"
        alarm_description   = "Alert when write requests are throttled"
        alarm_actions       = [aws_sns_topic.ops_alerts.arn]

        dimensions = {
          TableName = aws_dynamodb_table.example.name
        }
      }

      # Alarm for system errors
      resource "aws_cloudwatch_metric_alarm" "system_errors" {
        alarm_name          = "dynamodb-system-errors"
        comparison_operator = "GreaterThanThreshold"
        evaluation_periods  = "1"
        metric_name         = "SystemErrors"
        namespace           = "AWS/DynamoDB"
        period              = "300"
        statistic           = "Sum"
        threshold           = "5"
        alarm_description   = "Alert on DynamoDB system errors"
        alarm_actions       = [aws_sns_topic.ops_alerts.arn]

        dimensions = {
          TableName = aws_dynamodb_table.example.name
        }
      }

      # Auto Scaling for provisioned capacity (if not using on-demand)
      resource "aws_appautoscaling_target" "dynamodb_read" {
        max_capacity       = 100
        min_capacity       = 5
        resource_id        = "table/${aws_dynamodb_table.example.name}"
        scalable_dimension = "dynamodb:table:ReadCapacityUnits"
        service_namespace  = "dynamodb"
      }

      resource "aws_appautoscaling_policy" "dynamodb_read" {
        name               = "DynamoDBReadCapacityUtilization"
        policy_type        = "TargetTrackingScaling"
        resource_id        = aws_appautoscaling_target.dynamodb_read.resource_id
        scalable_dimension = aws_appautoscaling_target.dynamodb_read.scalable_dimension
        service_namespace  = aws_appautoscaling_target.dynamodb_read.service_namespace

        target_tracking_scaling_policy_configuration {
          predefined_metric_specification {
            predefined_metric_type = "DynamoDBReadCapacityUtilization"
          }
          target_value = 70.0
        }
      }
    cli_example: |
      # Create alarm for throttled requests
      aws cloudwatch put-metric-alarm \
        --alarm-name dynamodb-read-throttles \
        --alarm-description "Alert when read requests are throttled" \
        --metric-name ReadThrottleEvents \
        --namespace AWS/DynamoDB \
        --statistic Sum \
        --period 60 \
        --evaluation-periods 2 \
        --threshold 10 \
        --comparison-operator GreaterThanThreshold \
        --dimensions Name=TableName,Value=users \
        --alarm-actions arn:aws:sns:us-east-1:123456789012:ops-alerts

      # Get table metrics
      aws cloudwatch get-metric-statistics \
        --namespace AWS/DynamoDB \
        --metric-name ConsumedReadCapacityUnits \
        --dimensions Name=TableName,Value=users \
        --statistics Sum \
        --start-time 2024-01-01T00:00:00Z \
        --end-time 2024-01-01T23:59:59Z \
        --period 3600
    console_steps:
      - Navigate to DynamoDB console
      - Select table
      - Go to "Monitor" tab
      - View CloudWatch metrics
      - Click "Create alarm" for specific metric
      - Configure threshold and actions
      - Or navigate to CloudWatch console
      - Create alarms for DynamoDB metrics

  - category: access_control
    title: Implement Fine-Grained Access Control
    description: |
      Use IAM policies with condition keys to implement fine-grained access control at
      the item and attribute level. Restrict users to access only their own data using
      leading keys or attribute-based access control.
    compliance_frameworks:
      - HIPAA
      - SOC2
      - PCI-DSS
      - GDPR
    implementation: |
      Use IAM condition keys like dynamodb:LeadingKeys to restrict access to specific
      partition key values. Implement attribute-based access control to hide sensitive
      attributes. Use IAM roles with temporary credentials instead of long-term keys.
    terraform_example: |
      # IAM policy with fine-grained access control
      resource "aws_iam_policy" "user_data_access" {
        name        = "DynamoDBUserDataAccess"
        description = "Allow users to access only their own data"

        policy = jsonencode({
          Version = "2012-10-17"
          Statement = [
            {
              Sid    = "AllowAccessToOwnData"
              Effect = "Allow"
              Action = [
                "dynamodb:GetItem",
                "dynamodb:PutItem",
                "dynamodb:UpdateItem",
                "dynamodb:DeleteItem",
                "dynamodb:Query"
              ]
              Resource = "arn:aws:dynamodb:us-east-1:123456789012:table/users"
              Condition = {
                "ForAllValues:StringEquals" = {
                  "dynamodb:LeadingKeys" = ["$${aws:username}"]
                }
              }
            },
            {
              Sid    = "AllowListTables"
              Effect = "Allow"
              Action = [
                "dynamodb:ListTables"
              ]
              Resource = "*"
            },
            {
              Sid    = "DenyAccessToSensitiveAttributes"
              Effect = "Deny"
              Action = [
                "dynamodb:GetItem",
                "dynamodb:Query",
                "dynamodb:Scan"
              ]
              Resource = "arn:aws:dynamodb:us-east-1:123456789012:table/users"
              Condition = {
                "ForAnyValue:StringEquals" = {
                  "dynamodb:Attributes" = [
                    "ssn",
                    "creditCardNumber"
                  ]
                }
              }
            }
          ]
        })
      }

      # Attach policy to role
      resource "aws_iam_role_policy_attachment" "user_access" {
        role       = aws_iam_role.app_user_role.name
        policy_arn = aws_iam_policy.user_data_access.arn
      }
    cli_example: |
      # Create policy
      aws iam create-policy \
        --policy-name DynamoDBUserDataAccess \
        --policy-document file://user-data-policy.json

      # Attach to role
      aws iam attach-role-policy \
        --role-name AppUserRole \
        --policy-arn arn:aws:iam::123456789012:policy/DynamoDBUserDataAccess

      # Test access with specific user context
      aws sts assume-role \
        --role-arn arn:aws:iam::123456789012:role/AppUserRole \
        --role-session-name test-session
    console_steps:
      - Navigate to IAM console
      - Create new policy
      - Use visual editor or JSON
      - Add DynamoDB actions
      - Specify table ARN as resource
      - Add conditions:
        - dynamodb:LeadingKeys for partition key restriction
        - dynamodb:Attributes for attribute-level control
        - aws:username or custom claims for user-specific access
      - Create and attach policy to role
      - Test with different user contexts
