{
  "issue_number": 26,
  "title": "6.4 Basic Authentication",
  "body": "# 6.4 Basic Authentication\n\n## Parent Epic\nEpic 6: MVP Phase 1 - Container Product Foundation\n\n## Overview\n\nImplement simplified authentication for MVP single-tenant deployment. This provides email/password login with JWT tokens for a single admin user per container deployment.\n\n## Background\n\nMVP uses **Basic Auth** (email/password) because:\n- Trial customers don't need complex multi-user management\n- Reduces onboarding friction (no SSO setup required)\n- Single admin user simplifies container deployment\n- Full multi-user support deferred to Phase 4\n\n## Requirements\n\n| ID | Requirement | Acceptance Criteria |\n|----|-------------|---------------------|\n| USR-001 | User registration | Email/password registration, email validation format |\n| USR-004 | Profile management | View/update name, email; change password |\n| USR-007 | Password policies | Min 8 chars, 1 uppercase, 1 number; bcrypt hashing |\n\n## Technical Specification\n\n### Database Schema\n\n```sql\n-- Single user table (simplified for MVP)\nCREATE TABLE users (\n    user_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    email VARCHAR(255) NOT NULL UNIQUE,\n    password_hash VARCHAR(255) NOT NULL,\n    name VARCHAR(255),\n    is_admin BOOLEAN NOT NULL DEFAULT true,  -- MVP: all users are admin\n    email_verified BOOLEAN NOT NULL DEFAULT false,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    last_login_at TIMESTAMPTZ\n);\n\n-- Sessions table\nCREATE TABLE sessions (\n    session_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    user_id UUID NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,\n    token_hash VARCHAR(255) NOT NULL,  -- Hashed refresh token\n    expires_at TIMESTAMPTZ NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    revoked_at TIMESTAMPTZ\n);\n\nCREATE INDEX idx_sessions_user ON sessions(user_id);\nCREATE INDEX idx_sessions_token ON sessions(token_hash);\n```\n\n### Password Policy\n\n```python\n# src/cloud_optimizer/auth/password.py\nfrom passlib.context import CryptContext\nimport re\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\nclass PasswordPolicy:\n    MIN_LENGTH = 8\n    REQUIRE_UPPERCASE = True\n    REQUIRE_LOWERCASE = True\n    REQUIRE_NUMBER = True\n    REQUIRE_SPECIAL = False  # MVP: simplified\n\n    @classmethod\n    def validate(cls, password: str) -> List[str]:\n        \"\"\"Validate password against policy. Returns list of errors.\"\"\"\n        errors = []\n\n        if len(password) < cls.MIN_LENGTH:\n            errors.append(f\"Password must be at least {cls.MIN_LENGTH} characters\")\n\n        if cls.REQUIRE_UPPERCASE and not re.search(r\"[A-Z]\", password):\n            errors.append(\"Password must contain at least one uppercase letter\")\n\n        if cls.REQUIRE_LOWERCASE and not re.search(r\"[a-z]\", password):\n            errors.append(\"Password must contain at least one lowercase letter\")\n\n        if cls.REQUIRE_NUMBER and not re.search(r\"\\d\", password):\n            errors.append(\"Password must contain at least one number\")\n\n        return errors\n\n    @classmethod\n    def hash(cls, password: str) -> str:\n        \"\"\"Hash password using bcrypt.\"\"\"\n        return pwd_context.hash(password)\n\n    @classmethod\n    def verify(cls, password: str, hash: str) -> bool:\n        \"\"\"Verify password against hash.\"\"\"\n        return pwd_context.verify(password, hash)\n```\n\n### JWT Token Service\n\n```python\n# src/cloud_optimizer/auth/jwt.py\nfrom datetime import datetime, timedelta\nfrom jose import jwt, JWTError\nfrom pydantic import BaseModel\n\nclass TokenService:\n    ALGORITHM = \"HS256\"\n    ACCESS_TOKEN_EXPIRE_MINUTES = 15\n    REFRESH_TOKEN_EXPIRE_DAYS = 7\n\n    def __init__(self, secret_key: str):\n        self.secret_key = secret_key\n\n    def create_access_token(self, user_id: str, email: str) -> str:\n        \"\"\"Create short-lived access token.\"\"\"\n        expire = datetime.utcnow() + timedelta(minutes=self.ACCESS_TOKEN_EXPIRE_MINUTES)\n        payload = {\n            \"sub\": user_id,\n            \"email\": email,\n            \"type\": \"access\",\n            \"exp\": expire,\n            \"iat\": datetime.utcnow(),\n        }\n        return jwt.encode(payload, self.secret_key, algorithm=self.ALGORITHM)\n\n    def create_refresh_token(self, user_id: str) -> str:\n        \"\"\"Create long-lived refresh token.\"\"\"\n        expire = datetime.utcnow() + timedelta(days=self.REFRESH_TOKEN_EXPIRE_DAYS)\n        payload = {\n            \"sub\": user_id,\n            \"type\": \"refresh\",\n            \"exp\": expire,\n            \"iat\": datetime.utcnow(),\n            \"jti\": str(uuid.uuid4()),  # Unique token ID for revocation\n        }\n        return jwt.encode(payload, self.secret_key, algorithm=self.ALGORITHM)\n\n    def decode_token(self, token: str) -> dict:\n        \"\"\"Decode and validate token.\"\"\"\n        try:\n            payload = jwt.decode(token, self.secret_key, algorithms=[self.ALGORITHM])\n            return payload\n        except JWTError as e:\n            raise InvalidTokenException(str(e))\n```\n\n### Auth Service\n\n```python\n# src/cloud_optimizer/services/auth.py\nclass AuthService:\n    def __init__(self, db: AsyncSession, token_service: TokenService):\n        self.db = db\n        self.token_service = token_service\n\n    async def register(self, email: str, password: str, name: str = None) -> User:\n        \"\"\"Register new user.\"\"\"\n        # Check if user exists\n        existing = await self.db.execute(\n            select(User).where(User.email == email)\n        )\n        if existing.scalar_one_or_none():\n            raise UserAlreadyExistsException()\n\n        # Validate password\n        errors = PasswordPolicy.validate(password)\n        if errors:\n            raise PasswordValidationException(errors)\n\n        # Create user\n        user = User(\n            email=email,\n            password_hash=PasswordPolicy.hash(password),\n            name=name,\n            is_admin=True,  # MVP: all users are admin\n        )\n        self.db.add(user)\n        await self.db.commit()\n\n        return user\n\n    async def login(self, email: str, password: str) -> TokenPair:\n        \"\"\"Authenticate user and return tokens.\"\"\"\n        user = await self._get_user_by_email(email)\n        if not user:\n            raise InvalidCredentialsException()\n\n        if not PasswordPolicy.verify(password, user.password_hash):\n            raise InvalidCredentialsException()\n\n        # Update last login\n        user.last_login_at = datetime.utcnow()\n        await self.db.commit()\n\n        # Generate tokens\n        access_token = self.token_service.create_access_token(\n            str(user.user_id), user.email\n        )\n        refresh_token = self.token_service.create_refresh_token(str(user.user_id))\n\n        # Store refresh token hash\n        session = Session(\n            user_id=user.user_id,\n            token_hash=hashlib.sha256(refresh_token.encode()).hexdigest(),\n            expires_at=datetime.utcnow() + timedelta(days=7),\n        )\n        self.db.add(session)\n        await self.db.commit()\n\n        return TokenPair(\n            access_token=access_token,\n            refresh_token=refresh_token,\n            token_type=\"bearer\",\n            expires_in=self.token_service.ACCESS_TOKEN_EXPIRE_MINUTES * 60,\n        )\n\n    async def refresh(self, refresh_token: str) -> TokenPair:\n        \"\"\"Refresh access token using refresh token.\"\"\"\n        payload = self.token_service.decode_token(refresh_token)\n\n        if payload.get(\"type\") != \"refresh\":\n            raise InvalidTokenException(\"Not a refresh token\")\n\n        # Verify session exists and not revoked\n        token_hash = hashlib.sha256(refresh_token.encode()).hexdigest()\n        session = await self._get_session(token_hash)\n\n        if not session or session.revoked_at:\n            raise InvalidTokenException(\"Session revoked or expired\")\n\n        user = await self._get_user_by_id(session.user_id)\n\n        # Generate new access token\n        access_token = self.token_service.create_access_token(\n            str(user.user_id), user.email\n        )\n\n        return TokenPair(\n            access_token=access_token,\n            refresh_token=refresh_token,  # Reuse refresh token\n            token_type=\"bearer\",\n            expires_in=self.token_service.ACCESS_TOKEN_EXPIRE_MINUTES * 60,\n        )\n\n    async def logout(self, refresh_token: str):\n        \"\"\"Revoke refresh token.\"\"\"\n        token_hash = hashlib.sha256(refresh_token.encode()).hexdigest()\n        await self.db.execute(\n            update(Session)\n            .where(Session.token_hash == token_hash)\n            .values(revoked_at=datetime.utcnow())\n        )\n        await self.db.commit()\n```\n\n### Auth Middleware\n\n```python\n# src/cloud_optimizer/middleware/auth.py\nclass AuthMiddleware:\n    \"\"\"Validate JWT tokens on protected routes.\"\"\"\n\n    PUBLIC_PATHS = [\n        \"/health\",\n        \"/docs\",\n        \"/openapi.json\",\n        \"/api/v1/auth/login\",\n        \"/api/v1/auth/register\",\n        \"/api/v1/auth/refresh\",\n    ]\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send):\n        if scope[\"type\"] != \"http\":\n            await self.app(scope, receive, send)\n            return\n\n        path = scope[\"path\"]\n\n        # Skip auth for public paths\n        if any(path.startswith(p) for p in self.PUBLIC_PATHS):\n            await self.app(scope, receive, send)\n            return\n\n        # Extract token from header\n        headers = dict(scope[\"headers\"])\n        auth_header = headers.get(b\"authorization\", b\"\").decode()\n\n        if not auth_header.startswith(\"Bearer \"):\n            return await self._unauthorized(scope, receive, send)\n\n        token = auth_header[7:]\n\n        try:\n            payload = self.token_service.decode_token(token)\n            scope[\"state\"][\"user_id\"] = payload[\"sub\"]\n            scope[\"state\"][\"email\"] = payload[\"email\"]\n        except InvalidTokenException:\n            return await self._unauthorized(scope, receive, send)\n\n        await self.app(scope, receive, send)\n```\n\n## API Endpoints\n\n```\nPOST /api/v1/auth/register     # Register new user\nPOST /api/v1/auth/login        # Login, returns tokens\nPOST /api/v1/auth/refresh      # Refresh access token\nPOST /api/v1/auth/logout       # Revoke refresh token\nGET  /api/v1/auth/me           # Get current user profile\nPUT  /api/v1/auth/me           # Update profile\nPUT  /api/v1/auth/password     # Change password\n```\n\n## Files to Create\n\n```\nsrc/cloud_optimizer/auth/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 password.py              # Password policy and hashing\n\u251c\u2500\u2500 jwt.py                   # JWT token service\n\u2514\u2500\u2500 exceptions.py            # Auth exceptions\n\nsrc/cloud_optimizer/services/\n\u2514\u2500\u2500 auth.py                  # Auth service\n\nsrc/cloud_optimizer/models/\n\u251c\u2500\u2500 user.py                  # User model\n\u2514\u2500\u2500 session.py               # Session model\n\nsrc/cloud_optimizer/middleware/\n\u2514\u2500\u2500 auth.py                  # Auth middleware\n\nsrc/cloud_optimizer/api/routers/\n\u2514\u2500\u2500 auth.py                  # Auth API endpoints\n\nalembic/versions/\n\u2514\u2500\u2500 xxx_create_user_tables.py\n\ntests/auth/\n\u251c\u2500\u2500 test_password.py\n\u251c\u2500\u2500 test_jwt.py\n\u251c\u2500\u2500 test_auth_service.py\n\u2514\u2500\u2500 test_auth_api.py\n```\n\n## Testing Requirements\n\n### Unit Tests\n- [ ] `test_password_policy.py` - Password validation rules\n- [ ] `test_password_hashing.py` - Bcrypt hash/verify\n- [ ] `test_jwt_tokens.py` - Token creation/validation\n- [ ] `test_auth_service.py` - Register/login/refresh/logout\n\n### Integration Tests\n- [ ] `test_auth_api.py` - Full API flow\n\n## Acceptance Criteria Checklist\n\n- [ ] User can register with email/password\n- [ ] Password policy enforced (8+ chars, uppercase, number)\n- [ ] Passwords stored with bcrypt\n- [ ] Login returns access + refresh tokens\n- [ ] Access token expires in 15 minutes\n- [ ] Refresh token expires in 7 days\n- [ ] Token refresh works correctly\n- [ ] Logout revokes refresh token\n- [ ] Protected endpoints return 401 without valid token\n- [ ] User can view/update profile\n- [ ] User can change password\n- [ ] 80%+ test coverage\n\n## Dependencies\n\n- 6.1 Container Packaging (database schema)\n\n## Blocked By\n\n- 6.1 Container Packaging\n\n## Blocks\n\n- 6.5 Chat Interface UI (needs auth endpoints)\n\n## Estimated Effort\n\n0.5 weeks\n\n## Labels\n\n`auth`, `security`, `mvp`, `phase-1`, `P0`\n",
  "labels": [
    "security",
    "mvp",
    "phase-1",
    "P0",
    "auth"
  ],
  "assignees": [],
  "milestone": null,
  "created_at": null,
  "updated_at": null,
  "state": "OPEN",
  "context": {
    "complexity": "medium",
    "effort": "medium",
    "confidence": 0.8,
    "required_expertise": [
      "security",
      "backend",
      "database"
    ],
    "dependencies": [],
    "related_files": []
  },
  "generated_at": "2025-12-04T10:23:29.121248Z",
  "generated_by": "smart-scaffold-cli",
  "branch_name": "feature/issue-26-64basicauthentication"
}