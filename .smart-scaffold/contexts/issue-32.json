{
  "issue_number": 32,
  "title": "7.4 Findings Management System",
  "body": "# 7.4 Findings Management System\n\n## Parent Epic\nEpic 7: MVP Phase 2 - Security & Cost Scanning\n\n## Overview\n\nImplement the findings management system that stores, queries, and tracks remediation status for security and cost findings. Provides API for chat interface to query findings and display them to users.\n\n## Background\n\nAfter scanning, findings need to be:\n- Stored persistently for reference\n- Queryable by chat interface (\"What did you find?\")\n- Trackable for remediation status\n- Filterable by severity, service, compliance framework\n- Accessible for reporting\n\n## Requirements\n\n| ID | Requirement | Acceptance Criteria |\n|----|-------------|---------------------|\n| FND-001 | Finding storage | Store findings with full context, support both security and cost |\n| FND-002 | Finding queries | Filter by severity, service, compliance, date range |\n| FND-003 | Status tracking | Track open/acknowledged/resolved/false_positive status |\n| FND-004 | Finding details | Include remediation steps, code snippets, documentation links |\n| FND-005 | Finding summary | Aggregate statistics for dashboard and chat |\n\n## Technical Specification\n\n### Finding Service\n\n```python\n# src/cloud_optimizer/services/findings.py\nfrom sqlalchemy import select, func, and_\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nclass FindingsService:\n    def __init__(self, db: AsyncSession):\n        self.db = db\n\n    async def get_findings(\n        self,\n        tenant_id: UUID,\n        filters: FindingFilters = None,\n        pagination: Pagination = None,\n    ) -> FindingsPage:\n        \"\"\"Get findings with filtering and pagination.\"\"\"\n        query = select(SecurityFinding).where(\n            SecurityFinding.tenant_id == tenant_id\n        )\n\n        # Apply filters\n        if filters:\n            if filters.severity:\n                query = query.where(SecurityFinding.severity.in_(filters.severity))\n            if filters.resource_type:\n                query = query.where(SecurityFinding.resource_type.in_(filters.resource_type))\n            if filters.status:\n                query = query.where(SecurityFinding.status.in_(filters.status))\n            if filters.compliance_framework:\n                # JSONB containment query\n                query = query.where(\n                    SecurityFinding.compliance_frameworks.contains([filters.compliance_framework])\n                )\n            if filters.job_id:\n                query = query.where(SecurityFinding.job_id == filters.job_id)\n            if filters.search:\n                # Full-text search on title and description\n                search_pattern = f\"%{filters.search}%\"\n                query = query.where(\n                    or_(\n                        SecurityFinding.title.ilike(search_pattern),\n                        SecurityFinding.description.ilike(search_pattern),\n                        SecurityFinding.resource_id.ilike(search_pattern),\n                    )\n                )\n\n        # Default sort by severity, then created_at\n        query = query.order_by(\n            case(\n                (SecurityFinding.severity == \"critical\", 1),\n                (SecurityFinding.severity == \"high\", 2),\n                (SecurityFinding.severity == \"medium\", 3),\n                (SecurityFinding.severity == \"low\", 4),\n            ),\n            SecurityFinding.created_at.desc(),\n        )\n\n        # Get total count\n        count_query = select(func.count()).select_from(query.subquery())\n        total = (await self.db.execute(count_query)).scalar()\n\n        # Apply pagination\n        if pagination:\n            query = query.offset(pagination.offset).limit(pagination.limit)\n        else:\n            query = query.limit(100)\n\n        result = await self.db.execute(query)\n        findings = result.scalars().all()\n\n        return FindingsPage(\n            items=findings,\n            total=total,\n            page=pagination.page if pagination else 1,\n            page_size=pagination.limit if pagination else len(findings),\n        )\n\n    async def get_finding(self, tenant_id: UUID, finding_id: UUID) -> SecurityFinding:\n        \"\"\"Get single finding with full details.\"\"\"\n        result = await self.db.execute(\n            select(SecurityFinding)\n            .where(SecurityFinding.finding_id == finding_id)\n            .where(SecurityFinding.tenant_id == tenant_id)\n        )\n        finding = result.scalar_one_or_none()\n        if not finding:\n            raise FindingNotFoundException()\n        return finding\n\n    async def update_status(\n        self,\n        tenant_id: UUID,\n        finding_id: UUID,\n        status: str,\n        notes: str = None,\n    ) -> SecurityFinding:\n        \"\"\"Update finding status.\"\"\"\n        finding = await self.get_finding(tenant_id, finding_id)\n\n        finding.status = status\n        if status == \"resolved\":\n            finding.resolved_at = datetime.utcnow()\n\n        finding.updated_at = datetime.utcnow()\n        await self.db.commit()\n\n        return finding\n\n    async def get_summary(self, tenant_id: UUID) -> FindingsSummary:\n        \"\"\"Get aggregated findings summary.\"\"\"\n        # Severity breakdown\n        severity_query = select(\n            SecurityFinding.severity,\n            func.count(SecurityFinding.finding_id).label(\"count\"),\n        ).where(\n            SecurityFinding.tenant_id == tenant_id,\n            SecurityFinding.status == \"open\",\n        ).group_by(SecurityFinding.severity)\n\n        severity_result = await self.db.execute(severity_query)\n        by_severity = {row.severity: row.count for row in severity_result}\n\n        # Resource type breakdown\n        resource_query = select(\n            SecurityFinding.resource_type,\n            func.count(SecurityFinding.finding_id).label(\"count\"),\n        ).where(\n            SecurityFinding.tenant_id == tenant_id,\n            SecurityFinding.status == \"open\",\n        ).group_by(SecurityFinding.resource_type)\n\n        resource_result = await self.db.execute(resource_query)\n        by_resource = {row.resource_type: row.count for row in resource_result}\n\n        # Status breakdown\n        status_query = select(\n            SecurityFinding.status,\n            func.count(SecurityFinding.finding_id).label(\"count\"),\n        ).where(\n            SecurityFinding.tenant_id == tenant_id,\n        ).group_by(SecurityFinding.status)\n\n        status_result = await self.db.execute(status_query)\n        by_status = {row.status: row.count for row in status_result}\n\n        # Total counts\n        total_open = sum(\n            count for status, count in by_status.items() if status == \"open\"\n        )\n\n        return FindingsSummary(\n            total_findings=sum(by_status.values()),\n            open_findings=total_open,\n            by_severity=by_severity,\n            by_resource_type=by_resource,\n            by_status=by_status,\n        )\n\n    async def get_for_chat(self, tenant_id: UUID, query: str) -> list[FindingForChat]:\n        \"\"\"Get findings formatted for chat response.\"\"\"\n        # Parse natural language query for filters\n        filters = self._parse_chat_query(query)\n\n        # Get top findings\n        page = await self.get_findings(\n            tenant_id,\n            filters=filters,\n            pagination=Pagination(limit=10),\n        )\n\n        return [\n            FindingForChat(\n                resource=f.resource_name or f.resource_id,\n                title=f.title,\n                severity=f.severity,\n                compliance=f.compliance_frameworks,\n                remediation=f.remediation_steps[0] if f.remediation_steps else None,\n            )\n            for f in page.items\n        ]\n\n    def _parse_chat_query(self, query: str) -> FindingFilters:\n        \"\"\"Parse natural language into filters.\"\"\"\n        filters = FindingFilters()\n\n        query_lower = query.lower()\n\n        # Severity keywords\n        if \"critical\" in query_lower:\n            filters.severity = [\"critical\"]\n        elif \"high\" in query_lower:\n            filters.severity = [\"critical\", \"high\"]\n\n        # Resource types\n        if \"s3\" in query_lower or \"bucket\" in query_lower:\n            filters.resource_type = [\"s3_bucket\"]\n        elif \"ec2\" in query_lower or \"instance\" in query_lower:\n            filters.resource_type = [\"ec2_instance\"]\n        elif \"rds\" in query_lower or \"database\" in query_lower:\n            filters.resource_type = [\"rds_instance\"]\n\n        # Compliance frameworks\n        if \"hipaa\" in query_lower:\n            filters.compliance_framework = \"HIPAA\"\n        elif \"soc\" in query_lower or \"soc2\" in query_lower:\n            filters.compliance_framework = \"SOC2\"\n        elif \"pci\" in query_lower:\n            filters.compliance_framework = \"PCI-DSS\"\n\n        return filters\n```\n\n### Finding Models\n\n```python\n# src/cloud_optimizer/schemas/findings.py\nfrom pydantic import BaseModel\nfrom typing import Optional\nfrom datetime import datetime\n\nclass FindingFilters(BaseModel):\n    severity: Optional[list[str]] = None\n    resource_type: Optional[list[str]] = None\n    status: Optional[list[str]] = None\n    compliance_framework: Optional[str] = None\n    job_id: Optional[UUID] = None\n    search: Optional[str] = None\n\n\nclass Pagination(BaseModel):\n    page: int = 1\n    limit: int = 20\n\n    @property\n    def offset(self) -> int:\n        return (self.page - 1) * self.limit\n\n\nclass FindingResponse(BaseModel):\n    finding_id: UUID\n    resource_type: str\n    resource_id: str\n    resource_name: Optional[str]\n    region: str\n    rule_id: str\n    title: str\n    description: str\n    severity: str\n    compliance_frameworks: list[str]\n    remediation_steps: list[str]\n    remediation_code: Optional[str]\n    documentation_url: Optional[str]\n    status: str\n    created_at: datetime\n\n    class Config:\n        from_attributes = True\n\n\nclass FindingsPage(BaseModel):\n    items: list[FindingResponse]\n    total: int\n    page: int\n    page_size: int\n    total_pages: int\n\n    @property\n    def has_next(self) -> bool:\n        return self.page < self.total_pages\n\n\nclass FindingsSummary(BaseModel):\n    total_findings: int\n    open_findings: int\n    by_severity: dict[str, int]\n    by_resource_type: dict[str, int]\n    by_status: dict[str, int]\n\n\nclass FindingForChat(BaseModel):\n    \"\"\"Simplified finding for chat responses.\"\"\"\n    resource: str\n    title: str\n    severity: str\n    compliance: list[str]\n    remediation: Optional[str]\n\n\nclass UpdateFindingStatus(BaseModel):\n    status: str  # open, acknowledged, resolved, false_positive\n    notes: Optional[str] = None\n```\n\n### API Router\n\n```python\n# src/cloud_optimizer/api/routers/findings.py\nfrom fastapi import APIRouter, Depends, Query\n\nrouter = APIRouter(prefix=\"/api/v1/findings\", tags=[\"findings\"])\n\n@router.get(\"\", response_model=FindingsPage)\nasync def list_findings(\n    severity: list[str] = Query(None),\n    resource_type: list[str] = Query(None),\n    status: list[str] = Query(None),\n    compliance: str = Query(None),\n    search: str = Query(None),\n    page: int = Query(1, ge=1),\n    limit: int = Query(20, ge=1, le=100),\n    tenant_id: UUID = Depends(get_tenant_id),\n    findings_service: FindingsService = Depends(get_findings_service),\n):\n    \"\"\"List findings with filtering and pagination.\"\"\"\n    filters = FindingFilters(\n        severity=severity,\n        resource_type=resource_type,\n        status=status,\n        compliance_framework=compliance,\n        search=search,\n    )\n    pagination = Pagination(page=page, limit=limit)\n\n    return await findings_service.get_findings(tenant_id, filters, pagination)\n\n\n@router.get(\"/summary\", response_model=FindingsSummary)\nasync def get_summary(\n    tenant_id: UUID = Depends(get_tenant_id),\n    findings_service: FindingsService = Depends(get_findings_service),\n):\n    \"\"\"Get aggregated findings summary.\"\"\"\n    return await findings_service.get_summary(tenant_id)\n\n\n@router.get(\"/{finding_id}\", response_model=FindingResponse)\nasync def get_finding(\n    finding_id: UUID,\n    tenant_id: UUID = Depends(get_tenant_id),\n    findings_service: FindingsService = Depends(get_findings_service),\n):\n    \"\"\"Get finding details.\"\"\"\n    return await findings_service.get_finding(tenant_id, finding_id)\n\n\n@router.put(\"/{finding_id}/status\", response_model=FindingResponse)\nasync def update_status(\n    finding_id: UUID,\n    body: UpdateFindingStatus,\n    tenant_id: UUID = Depends(get_tenant_id),\n    findings_service: FindingsService = Depends(get_findings_service),\n):\n    \"\"\"Update finding status.\"\"\"\n    return await findings_service.update_status(\n        tenant_id, finding_id, body.status, body.notes\n    )\n\n\n@router.get(\"/for-chat\", response_model=list[FindingForChat])\nasync def get_for_chat(\n    query: str = Query(..., description=\"Natural language query\"),\n    tenant_id: UUID = Depends(get_tenant_id),\n    findings_service: FindingsService = Depends(get_findings_service),\n):\n    \"\"\"Get findings formatted for chat response.\"\"\"\n    return await findings_service.get_for_chat(tenant_id, query)\n```\n\n## API Endpoints\n\n```\nGET  /api/v1/findings                # List findings (with filters)\nGET  /api/v1/findings/summary        # Get aggregated summary\nGET  /api/v1/findings/:id            # Get finding details\nPUT  /api/v1/findings/:id/status     # Update status\nGET  /api/v1/findings/for-chat       # Get findings for chat\nGET  /api/v1/findings/export         # Export findings (CSV/JSON)\n```\n\n## Files to Create\n\n```\nsrc/cloud_optimizer/services/\n\u2514\u2500\u2500 findings.py                  # Findings service\n\nsrc/cloud_optimizer/schemas/\n\u2514\u2500\u2500 findings.py                  # Pydantic schemas\n\nsrc/cloud_optimizer/api/routers/\n\u2514\u2500\u2500 findings.py                  # API endpoints\n\ntests/services/\n\u2514\u2500\u2500 test_findings.py             # Findings service tests\n\ntests/api/\n\u2514\u2500\u2500 test_findings_api.py         # API tests\n```\n\n## Testing Requirements\n\n### Unit Tests\n- [ ] `test_findings_filters.py` - Filter query building\n- [ ] `test_findings_pagination.py` - Pagination logic\n- [ ] `test_findings_summary.py` - Aggregation logic\n- [ ] `test_chat_query_parsing.py` - NL to filters\n\n### Integration Tests\n- [ ] `test_findings_service.py` - Full service with DB\n- [ ] `test_findings_api.py` - API endpoints\n\n## Acceptance Criteria Checklist\n\n- [ ] Findings stored with full context\n- [ ] Filter by severity works\n- [ ] Filter by resource type works\n- [ ] Filter by status works\n- [ ] Filter by compliance framework works\n- [ ] Full-text search works\n- [ ] Pagination with correct totals\n- [ ] Status update persists\n- [ ] Summary aggregation accurate\n- [ ] Chat query parsing extracts filters\n- [ ] Export to CSV/JSON works\n- [ ] 80%+ test coverage\n\n## Dependencies\n\n- 7.2 Security Scanner (generates findings)\n- 7.3 Cost Scanner (generates findings)\n\n## Blocked By\n\n- 7.2 Security Scanner\n\n## Blocks\n\n- 8.3 Security Analysis (IB queries findings)\n\n## Estimated Effort\n\n1 week\n\n## Labels\n\n`findings`, `data`, `api`, `mvp`, `phase-2`, `P0`\n",
  "labels": [
    "mvp",
    "phase-2",
    "P0",
    "findings",
    "data",
    "api"
  ],
  "assignees": [],
  "milestone": null,
  "created_at": null,
  "updated_at": null,
  "state": "OPEN",
  "context": {
    "complexity": "medium",
    "effort": "medium",
    "confidence": 0.8,
    "required_expertise": [
      "backend",
      "database"
    ],
    "dependencies": [],
    "related_files": []
  },
  "generated_at": "2025-12-04T12:01:09.567943Z",
  "generated_by": "smart-scaffold-cli",
  "branch_name": "feature/issue-32-74findingsmanagementsystem"
}