AWSTemplateFormatVersion: '2010-09-09'
Description: 'AWS Secrets Manager configuration for Cloud Optimizer with automatic credential rotation'

Parameters:
  Environment:
    Type: String
    Default: production
    AllowedValues:
      - development
      - staging
      - production
    Description: Environment name for resource tagging and naming

  RotationSchedule:
    Type: Number
    Default: 30
    MinValue: 1
    MaxValue: 365
    Description: Number of days between automatic credential rotation (default 30 days)

  DatabaseEngine:
    Type: String
    Default: postgres
    AllowedValues:
      - postgres
      - mysql
      - mariadb
    Description: Database engine type for rotation Lambda

  VpcId:
    Type: String
    Description: VPC ID where the rotation Lambda will run (must have access to RDS)
    Default: ''

  SubnetIds:
    Type: CommaDelimitedList
    Description: Comma-separated list of subnet IDs for Lambda (private subnets with NAT gateway recommended)
    Default: ''

  DatabaseSecurityGroupId:
    Type: String
    Description: Security group ID that allows access to the database
    Default: ''

Conditions:
  HasVpcConfig: !Not [!Equals [!Ref VpcId, '']]
  IsProduction: !Equals [!Ref Environment, production]

Resources:
  # KMS Key for Secrets Encryption
  SecretsKMSKey:
    Type: AWS::KMS::Key
    Properties:
      Description: !Sub 'KMS key for Cloud Optimizer ${Environment} secrets encryption'
      EnableKeyRotation: true
      KeyPolicy:
        Version: '2012-10-17'
        Statement:
          - Sid: Enable IAM User Permissions
            Effect: Allow
            Principal:
              AWS: !Sub 'arn:aws:iam::${AWS::AccountId}:root'
            Action: 'kms:*'
            Resource: '*'
          - Sid: Allow Secrets Manager to use the key
            Effect: Allow
            Principal:
              Service: secretsmanager.amazonaws.com
            Action:
              - 'kms:Decrypt'
              - 'kms:DescribeKey'
              - 'kms:CreateGrant'
            Resource: '*'
            Condition:
              StringEquals:
                'kms:ViaService': !Sub 'secretsmanager.${AWS::Region}.amazonaws.com'
          - Sid: Allow CloudWatch Logs to use the key
            Effect: Allow
            Principal:
              Service: !Sub 'logs.${AWS::Region}.amazonaws.com'
            Action:
              - 'kms:Decrypt'
              - 'kms:Encrypt'
              - 'kms:GenerateDataKey'
            Resource: '*'
            Condition:
              ArnLike:
                'kms:EncryptionContext:aws:logs:arn': !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*'
      Tags:
        - Key: Name
          Value: !Sub 'cloud-optimizer-${Environment}-secrets-kms'
        - Key: Environment
          Value: !Ref Environment
        - Key: ManagedBy
          Value: CloudFormation
        - Key: Application
          Value: CloudOptimizer

  SecretsKMSKeyAlias:
    Type: AWS::KMS::Alias
    Properties:
      AliasName: !Sub 'alias/cloud-optimizer-${Environment}-secrets'
      TargetKeyId: !Ref SecretsKMSKey

  # Database Credentials Secret
  DatabaseCredentialsSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub 'cloud-optimizer/${Environment}/database/credentials'
      Description: !Sub 'Database credentials for Cloud Optimizer ${Environment} environment with automatic rotation'
      KmsKeyId: !Ref SecretsKMSKey
      GenerateSecretString:
        SecretStringTemplate: '{"username": "cloudguardian"}'
        GenerateStringKey: 'password'
        PasswordLength: 32
        ExcludePunctuation: false
        ExcludeCharacters: '"@/\'
        RequireEachIncludedType: true
      Tags:
        - Key: Name
          Value: !Sub 'cloud-optimizer-${Environment}-db-credentials'
        - Key: Environment
          Value: !Ref Environment
        - Key: ManagedBy
          Value: CloudFormation
        - Key: Application
          Value: CloudOptimizer
        - Key: SecretType
          Value: DatabaseCredentials

  # API Keys Secret
  APIKeysSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub 'cloud-optimizer/${Environment}/api/keys'
      Description: !Sub 'API keys and tokens for Cloud Optimizer ${Environment} environment'
      KmsKeyId: !Ref SecretsKMSKey
      SecretString: !Sub |
        {
          "jwt_secret_key": "",
          "aws_access_key_id": "",
          "aws_secret_access_key": "",
          "external_api_keys": {}
        }
      Tags:
        - Key: Name
          Value: !Sub 'cloud-optimizer-${Environment}-api-keys'
        - Key: Environment
          Value: !Ref Environment
        - Key: ManagedBy
          Value: CloudFormation
        - Key: Application
          Value: CloudOptimizer
        - Key: SecretType
          Value: APIKeys

  # Third-party Integration Secrets
  IntegrationSecretsSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub 'cloud-optimizer/${Environment}/integrations/credentials'
      Description: !Sub 'Third-party integration credentials for Cloud Optimizer ${Environment} environment'
      KmsKeyId: !Ref SecretsKMSKey
      SecretString: !Sub |
        {
          "slack_webhook_url": "",
          "pagerduty_api_key": "",
          "datadog_api_key": "",
          "github_token": ""
        }
      Tags:
        - Key: Name
          Value: !Sub 'cloud-optimizer-${Environment}-integrations'
        - Key: Environment
          Value: !Ref Environment
        - Key: ManagedBy
          Value: CloudFormation
        - Key: Application
          Value: CloudOptimizer
        - Key: SecretType
          Value: IntegrationCredentials

  # IAM Role for Rotation Lambda
  RotationLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'cloud-optimizer-${Environment}-rotation-lambda-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
        - !If
          - HasVpcConfig
          - 'arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole'
          - !Ref AWS::NoValue
      Policies:
        - PolicyName: SecretsManagerRotationPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'secretsmanager:DescribeSecret'
                  - 'secretsmanager:GetSecretValue'
                  - 'secretsmanager:PutSecretValue'
                  - 'secretsmanager:UpdateSecretVersionStage'
                Resource:
                  - !Ref DatabaseCredentialsSecret
                  - !Ref APIKeysSecret
              - Effect: Allow
                Action:
                  - 'secretsmanager:GetRandomPassword'
                Resource: '*'
              - Effect: Allow
                Action:
                  - 'kms:Decrypt'
                  - 'kms:Encrypt'
                  - 'kms:GenerateDataKey'
                  - 'kms:DescribeKey'
                Resource: '*'
                Condition:
                  StringEquals:
                    'kms:ViaService': !Sub 'secretsmanager.${AWS::Region}.amazonaws.com'
              - Effect: Allow
                Action:
                  - 'rds:DescribeDBInstances'
                  - 'rds:DescribeDBClusters'
                Resource: '*'
      Tags:
        - Key: Name
          Value: !Sub 'cloud-optimizer-${Environment}-rotation-lambda-role'
        - Key: Environment
          Value: !Ref Environment
        - Key: ManagedBy
          Value: CloudFormation
        - Key: Application
          Value: CloudOptimizer

  # Security Group for Rotation Lambda (if VPC is configured)
  RotationLambdaSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Condition: HasVpcConfig
    Properties:
      GroupName: !Sub 'cloud-optimizer-${Environment}-rotation-lambda-sg'
      GroupDescription: Security group for Secrets Manager rotation Lambda function
      VpcId: !Ref VpcId
      SecurityGroupEgress:
        - IpProtocol: tcp
          FromPort: 5432
          ToPort: 5432
          Description: PostgreSQL database access
          DestinationSecurityGroupId: !Ref DatabaseSecurityGroupId
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
          Description: HTTPS for AWS API calls
      Tags:
        - Key: Name
          Value: !Sub 'cloud-optimizer-${Environment}-rotation-lambda-sg'
        - Key: Environment
          Value: !Ref Environment
        - Key: ManagedBy
          Value: CloudFormation
        - Key: Application
          Value: CloudOptimizer

  # Lambda Function for Database Credential Rotation
  DatabaseRotationLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'cloud-optimizer-${Environment}-db-rotation'
      Description: !Sub 'Automatic rotation of database credentials for Cloud Optimizer ${Environment}'
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !GetAtt RotationLambdaRole.Arn
      Timeout: 30
      MemorySize: 256
      Environment:
        Variables:
          DATABASE_ENGINE: !Ref DatabaseEngine
          SECRETS_MANAGER_ENDPOINT: !Sub 'https://secretsmanager.${AWS::Region}.amazonaws.com'
      VpcConfig: !If
        - HasVpcConfig
        - SecurityGroupIds:
            - !Ref RotationLambdaSecurityGroup
          SubnetIds: !Ref SubnetIds
        - !Ref AWS::NoValue
      Code:
        ZipFile: |
          import boto3
          import json
          import logging
          import os
          import psycopg2
          from typing import Dict, Any

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event: Dict[str, Any], context: Any) -> None:
              """AWS Secrets Manager rotation handler for PostgreSQL credentials.

              Args:
                  event: Lambda event containing rotation details
                  context: Lambda context object

              Raises:
                  ValueError: If rotation step is invalid
                  Exception: If rotation fails
              """
              arn = event['SecretId']
              token = event['ClientRequestToken']
              step = event['Step']

              service_client = boto3.client('secretsmanager', endpoint_url=os.environ.get('SECRETS_MANAGER_ENDPOINT'))

              metadata = service_client.describe_secret(SecretId=arn)
              if not metadata['RotationEnabled']:
                  logger.error(f"Secret {arn} is not enabled for rotation")
                  raise ValueError(f"Secret {arn} is not enabled for rotation")

              versions = metadata['VersionIdsToStages']
              if token not in versions:
                  logger.error(f"Secret version {token} has no stage for rotation of secret {arn}")
                  raise ValueError(f"Secret version {token} has no stage for rotation of secret {arn}")
              if "AWSCURRENT" in versions[token]:
                  logger.info(f"Secret version {token} already set as AWSCURRENT for secret {arn}")
                  return
              elif "AWSPENDING" not in versions[token]:
                  logger.error(f"Secret version {token} not set as AWSPENDING for rotation of secret {arn}")
                  raise ValueError(f"Secret version {token} not set as AWSPENDING for rotation of secret {arn}")

              if step == "createSecret":
                  create_secret(service_client, arn, token)
              elif step == "setSecret":
                  set_secret(service_client, arn, token)
              elif step == "testSecret":
                  test_secret(service_client, arn, token)
              elif step == "finishSecret":
                  finish_secret(service_client, arn, token)
              else:
                  raise ValueError("Invalid step parameter")


          def create_secret(service_client: Any, arn: str, token: str) -> None:
              """Generate a new secret version with a new password.

              Args:
                  service_client: Boto3 Secrets Manager client
                  arn: ARN of the secret
                  token: ClientRequestToken for the new version
              """
              try:
                  service_client.get_secret_value(SecretId=arn, VersionId=token, VersionStage="AWSPENDING")
                  logger.info("createSecret: Successfully retrieved secret for %s." % arn)
              except service_client.exceptions.ResourceNotFoundException:
                  current_dict = json.loads(service_client.get_secret_value(SecretId=arn, VersionStage="AWSCURRENT")['SecretString'])

                  current_dict['password'] = service_client.get_random_password(
                      ExcludePunctuation=False,
                      ExcludeCharacters='"@/\\\'',
                      PasswordLength=32,
                      RequireEachIncludedType=True
                  )['RandomPassword']

                  service_client.put_secret_value(
                      SecretId=arn,
                      ClientRequestToken=token,
                      SecretString=json.dumps(current_dict),
                      VersionStages=['AWSPENDING']
                  )
                  logger.info("createSecret: Successfully created secret for %s." % arn)


          def set_secret(service_client: Any, arn: str, token: str) -> None:
              """Set the new password in the database.

              Args:
                  service_client: Boto3 Secrets Manager client
                  arn: ARN of the secret
                  token: ClientRequestToken for the new version
              """
              pending_dict = json.loads(service_client.get_secret_value(SecretId=arn, VersionId=token, VersionStage="AWSPENDING")['SecretString'])
              current_dict = json.loads(service_client.get_secret_value(SecretId=arn, VersionStage="AWSCURRENT")['SecretString'])

              engine = os.environ.get('DATABASE_ENGINE', 'postgres')

              if engine == 'postgres':
                  try:
                      conn = psycopg2.connect(
                          host=current_dict.get('host', 'localhost'),
                          port=current_dict.get('port', 5432),
                          database=current_dict.get('dbname', 'cloudguardian'),
                          user=current_dict['username'],
                          password=current_dict['password'],
                          connect_timeout=5
                      )

                      with conn.cursor() as cursor:
                          cursor.execute(f"ALTER USER {pending_dict['username']} WITH PASSWORD %s", (pending_dict['password'],))
                          conn.commit()

                      conn.close()
                      logger.info("setSecret: Successfully set password in database for %s." % arn)
                  except Exception as e:
                      logger.error(f"setSecret: Failed to update password in database: {str(e)}")
                      raise
              else:
                  raise ValueError(f"Unsupported database engine: {engine}")


          def test_secret(service_client: Any, arn: str, token: str) -> None:
              """Test the new password by connecting to the database.

              Args:
                  service_client: Boto3 Secrets Manager client
                  arn: ARN of the secret
                  token: ClientRequestToken for the new version
              """
              pending_dict = json.loads(service_client.get_secret_value(SecretId=arn, VersionId=token, VersionStage="AWSPENDING")['SecretString'])

              engine = os.environ.get('DATABASE_ENGINE', 'postgres')

              if engine == 'postgres':
                  try:
                      conn = psycopg2.connect(
                          host=pending_dict.get('host', 'localhost'),
                          port=pending_dict.get('port', 5432),
                          database=pending_dict.get('dbname', 'cloudguardian'),
                          user=pending_dict['username'],
                          password=pending_dict['password'],
                          connect_timeout=5
                      )

                      with conn.cursor() as cursor:
                          cursor.execute("SELECT 1")
                          cursor.fetchone()

                      conn.close()
                      logger.info("testSecret: Successfully validated new credentials for %s." % arn)
                  except Exception as e:
                      logger.error(f"testSecret: Failed to validate new credentials: {str(e)}")
                      raise
              else:
                  raise ValueError(f"Unsupported database engine: {engine}")


          def finish_secret(service_client: Any, arn: str, token: str) -> None:
              """Finalize the rotation by marking the new version as current.

              Args:
                  service_client: Boto3 Secrets Manager client
                  arn: ARN of the secret
                  token: ClientRequestToken for the new version
              """
              metadata = service_client.describe_secret(SecretId=arn)
              current_version = None
              for version in metadata["VersionIdsToStages"]:
                  if "AWSCURRENT" in metadata["VersionIdsToStages"][version]:
                      if version == token:
                          logger.info("finishSecret: Version %s already marked as AWSCURRENT for %s" % (version, arn))
                          return
                      current_version = version
                      break

              service_client.update_secret_version_stage(
                  SecretId=arn,
                  VersionStage="AWSCURRENT",
                  MoveToVersionId=token,
                  RemoveFromVersionId=current_version
              )
              logger.info("finishSecret: Successfully set AWSCURRENT stage to version %s for secret %s." % (token, arn))

      Tags:
        - Key: Name
          Value: !Sub 'cloud-optimizer-${Environment}-db-rotation'
        - Key: Environment
          Value: !Ref Environment
        - Key: ManagedBy
          Value: CloudFormation
        - Key: Application
          Value: CloudOptimizer

  # Lambda Permission for Secrets Manager
  DatabaseRotationLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref DatabaseRotationLambda
      Action: 'lambda:InvokeFunction'
      Principal: secretsmanager.amazonaws.com

  # Rotation Schedule for Database Credentials
  DatabaseCredentialsRotationSchedule:
    Type: AWS::SecretsManager::RotationSchedule
    DependsOn: DatabaseRotationLambdaPermission
    Properties:
      SecretId: !Ref DatabaseCredentialsSecret
      RotationLambdaARN: !GetAtt DatabaseRotationLambda.Arn
      RotationRules:
        AutomaticallyAfterDays: !Ref RotationSchedule
        Duration: 2h
        ScheduleExpression: !If
          - IsProduction
          - 'rate(30 days)'
          - 'rate(7 days)'

  # CloudWatch Log Group for Rotation Lambda
  RotationLambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/cloud-optimizer-${Environment}-db-rotation'
      RetentionInDays: !If
        - IsProduction
        - 90
        - 30
      Tags:
        - Key: Name
          Value: !Sub 'cloud-optimizer-${Environment}-rotation-logs'
        - Key: Environment
          Value: !Ref Environment
        - Key: ManagedBy
          Value: CloudFormation
        - Key: Application
          Value: CloudOptimizer

  # CloudWatch Alarm for Rotation Failures
  RotationFailureAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub 'cloud-optimizer-${Environment}-rotation-failure'
      AlarmDescription: Alert when database credential rotation fails
      MetricName: Errors
      Namespace: AWS/Lambda
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: FunctionName
          Value: !Ref DatabaseRotationLambda
      TreatMissingData: notBreaching
      Tags:
        - Key: Name
          Value: !Sub 'cloud-optimizer-${Environment}-rotation-failure-alarm'
        - Key: Environment
          Value: !Ref Environment
        - Key: ManagedBy
          Value: CloudFormation
        - Key: Application
          Value: CloudOptimizer

  # Resource Policy for Secrets Manager (optional, for cross-account access)
  DatabaseCredentialsResourcePolicy:
    Type: AWS::SecretsManager::ResourcePolicy
    Properties:
      SecretId: !Ref DatabaseCredentialsSecret
      ResourcePolicy:
        Version: '2012-10-17'
        Statement:
          - Effect: Deny
            Principal: '*'
            Action: 'secretsmanager:DeleteSecret'
            Resource: '*'
            Condition:
              StringNotEquals:
                'aws:PrincipalAccount': !Ref AWS::AccountId

Outputs:
  DatabaseCredentialsSecretArn:
    Description: ARN of the database credentials secret
    Value: !Ref DatabaseCredentialsSecret
    Export:
      Name: !Sub '${AWS::StackName}-DatabaseCredentialsSecretArn'

  DatabaseCredentialsSecretName:
    Description: Name of the database credentials secret
    Value: !Sub 'cloud-optimizer/${Environment}/database/credentials'
    Export:
      Name: !Sub '${AWS::StackName}-DatabaseCredentialsSecretName'

  APIKeysSecretArn:
    Description: ARN of the API keys secret
    Value: !Ref APIKeysSecret
    Export:
      Name: !Sub '${AWS::StackName}-APIKeysSecretArn'

  APIKeysSecretName:
    Description: Name of the API keys secret
    Value: !Sub 'cloud-optimizer/${Environment}/api/keys'
    Export:
      Name: !Sub '${AWS::StackName}-APIKeysSecretName'

  IntegrationSecretsArn:
    Description: ARN of the integration secrets
    Value: !Ref IntegrationSecretsSecret
    Export:
      Name: !Sub '${AWS::StackName}-IntegrationSecretsArn'

  IntegrationSecretsName:
    Description: Name of the integration secrets
    Value: !Sub 'cloud-optimizer/${Environment}/integrations/credentials'
    Export:
      Name: !Sub '${AWS::StackName}-IntegrationSecretsName'

  KMSKeyId:
    Description: ID of the KMS key used for secrets encryption
    Value: !Ref SecretsKMSKey
    Export:
      Name: !Sub '${AWS::StackName}-SecretsKMSKeyId'

  KMSKeyArn:
    Description: ARN of the KMS key used for secrets encryption
    Value: !GetAtt SecretsKMSKey.Arn
    Export:
      Name: !Sub '${AWS::StackName}-SecretsKMSKeyArn'

  RotationLambdaArn:
    Description: ARN of the rotation Lambda function
    Value: !GetAtt DatabaseRotationLambda.Arn
    Export:
      Name: !Sub '${AWS::StackName}-RotationLambdaArn'

  RotationScheduleDays:
    Description: Number of days between automatic rotations
    Value: !Ref RotationSchedule
    Export:
      Name: !Sub '${AWS::StackName}-RotationScheduleDays'
